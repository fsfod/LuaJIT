local util = require("jitlog.util")
local format = string.format
local buildtemplate = util.buildtemplate

local generator = {
  outputlang = "lua",
  default_filename = "reader_def.lua",
}

generator.templates = {
  comment_line = "-- %s",
  namelist = [[
local {{name}} = {
{{list:  "%s",\\n}}}

]],

  enum = [[
local {{name}} = util.make_enum{
{{list}}}
lib.{{name}} = {{name}}

]],
  enumline = '"%s",\n',
  msgsizes = [[local msgsizes = {
{{list:  %s\n}} };
lib.msgsizes = msgsizes

]],
  struct = [[
typedef struct {{name}}{
  {{fields}}
}__attribute__((packed)) {{name}};

]],
  msgstruct = [=[
  {{name}} = ffi.typeof([[
  struct { {{fields}}
  }__attribute__((packed))
]]),

]=],
  structfield = "\n  %s %s;",
  struct_comment = "// %s",

  msg_metatable = [[
do
  local {{name}} = {}

{{fields:%s}}

  local getters = {
{{getter_names:    %s\n}}  }

  local function {{name}}_indexer(self, key)
    local getter = getters[key]
    if getter then
      return (getter(self))
    else
      local value = {{name}}[key]
      if not value then
        error("Unknown field " .. key .. " in message type {{name}}")
      end
      return value
    end
  end
  
  local {{name}}_mt = {
    __index =  {{name}}_indexer,
    getters = getters,
    funcs = {{name}},
  }
  
  ffi.metatype(msgtypes.{{name}}, {{name}}_mt)
end

]],

  msg_getter = [[
  function {{msgname}}:get_{{name}}()
    assert(self, "Expected a '{{msgname}}' message as first parameter")
    return {{body}}
  end

]],

  msg_vgetter = [[
  function {{msgname}}:get_{{name}}()
    assert(self, "Expected a '{{msgname}}' message as first parameter")
    local array, size = get_fbarray(self, self.{{name}}_offset, {{offset}}, {{type}})
    return {{body}}
  end
]],

  msg_strgetter = [[
  function {{msgname}}:get_{{name}}()
    assert(self, "Expected a '{{msgname}}' message as first parameter")
    return (get_fbstring(self, self.{{name}}_offset, {{offset}}))
  end
]],

  boundscheck_func = [[
  function {{name}}:check(limit)
    local offset = {{msgsize}}
    local msg = ffi_cast("char*", self)
{{checks :%s}}  end]],

  boundscheck_line = [[
    offset = self.{{name}}_offset
    if offset ~= 0 then
      offset = offset + {{offset}}
      assert(offset > 4 and offset <= (limit-4),  "Bad field offset for {{name}}")
      
      local count = getarray_count(msg, offset)
      offset = offset + 4 + (count * {{element_size}})
      assert(offset <= limit, "Bad field length for {{name}}")
    end
]],
  vtable = [[
  {{name}} = { {{offsets}} },
]],
}

function generator:fmt_fieldget(def, f)
  return "self."..f.name
end

function generator:needs_accessor(struct, f)
  return f.vlen or f.bitfield or f.bitstorage ~= nil
end

function generator:fmt_accessor_def(struct, f, voffset) 
  local body
  local template = self.templates.msg_getter
  local tvalues = {
    msgname = struct.name,
    name = f.name,
    offset = f.offset,
    default = "false",
    type = "nil",
  }

  if f.vlen then
    template = self.templates.msg_vgetter

    if f.type == "string" then
      template = self.templates.msg_strgetter
    elseif f.type == "stringlist" then
      tvalues.default = "{}"
      body = format("(parse_strlist(array, size))", body)
    else
      tvalues.type = '"'..self.types[f.type].c..'"'
      -- Add the buffer element count and element size as extra return values
      body = "array, size"
    end
  elseif f.bitfield or f.bitstorage then
    body = format("(band(rshift(%s, %d), 0x%x))", "self." .. f.bitstorage, f.bitofs, bit.lshift(1, f.bitsize)-1)
    if f.bool then
      body = body .. " ~= 0"
    end
  else
    assert(body, "unhandled field accessor type")
  end

  tvalues.body = body
  -- Prevent a tail call be generated by wrapping the body in parentheses
  return buildtemplate(template, tvalues)
end

function generator:fmt_accessor_get(struct, f, msgvar)
  return format("%s:get_%s()", msgvar, f.name)
end

function generator:fmt_namelookup(enum, idvar)
  return format("%s_names[%s]", enum, idvar)
end

function generator:write_vtables()
  self:write("local vtables = {\n")

  for _, msgdef in ipairs(self.msglist) do
    self:write_vtable(msgdef, "message")
  end

  for _, structdef in ipairs(self.structlist) do
    self:write_vtable(structdef, "struct")
  end

  self:write("};\n")
  self:write("lib.vtables = vtables\n")

  self:write("local vtable_names = {\n")

  for _, def in ipairs(self.msglist) do
    self:writef("  [\"%s\"] = {%s},\n", def.name, util.concatf(def.vtable_names, "\"%s\", "))
  end

  self:write("};\n")
  self:write("lib.vtable_names = vtable_names\n")
end

function generator:writefile(options)
  self:write([=[
local util = require("jitlog.util")
local ffi = require("ffi")
local ffi_cast = ffi.cast
local ffi_string = ffi.string
local band, rshift = bit.band, bit.rshift
local get_fbarray, get_fbstring = util.get_fbarray, util.get_fbstring
local lib = {}

local function parse_strlist(strlist, bufsize)
  local t = {}  
  if not strlist then
    -- Varible was not present so return an empty list
    return t
  end
  
  local buf = ffi.cast("const char *", strlist)
  local prev = 0
  
  for i =0, bufsize-1 do
    if buf[i] == 0 then
      local length = i - prev
      assert(length > 0)
      t[#t + 1] = ffi_string(buf +  prev, length)
      prev = i+1
    end
  end
  return t
end

local function getarray_count(msg, offset, adjustment)
  local array = msg + (adjustment or 0) + offset
  return ffi_cast("uint32_t*", array)[0]
end

local function nop() end

]=])
  self:write_enum("MsgType", self.sorted_msgnames)
  self:write_msgsizes(false)
  self:write_vtables()

  if GC64 then
    self:write([[

lib.GC64 = true

ffi.cdef("typedef uint64_t GCRef, MRef, GCSize;")]])
  else
    self:write([[

lib.GC64 = false

ffi.cdef("typedef uint32_t GCRef, MRef, GCSize;")]])
  end
  self:write([=[

ffi.cdef[[
]=])
  local struct_getters = {}
  for _, def in ipairs(self.structlist) do
    local field_getters = self:write_struct(def.name, def)
    if field_getters then
      struct_getters[def.name] = field_getters
    end
  end
  self:writeline("]]")

  self:writeline("local msgtypes = {")
  for _, def in ipairs(self.msglist) do
    local field_getters = self:write_struct(def.name, def)
    if field_getters then
      struct_getters[def.name] = field_getters
    end
  end
  self:writeline("}")
  self:write("lib.msgtypes = msgtypes\n\n")

  for _, def in ipairs(self.msglist) do
    self:writef("assert(ffi.sizeof(msgtypes.%s) == %d)\n", def.name, def.size)
  end
  self:writeline()
  
  for _, def in ipairs(self.msglist) do
    local funclist = struct_getters[def.name]
    local getters = {}
    if not funclist then
      funclist = {format("  %s.check = nop", def.name)}
    else
      if #def.vlen_fields > 0 and not def.use_msgsize then
        table.insert(funclist, self:build_boundscheck(def))
      else
        table.insert(funclist, format("  %s.check = nop", def.name))
      end

      -- Build a table of properties names to getter functions used by the indexer
      for _, f in ipairs(def.fields) do
        if self:needs_accessor(def, f) and (not f.vlen or f.type == "string" or f.type == "stringlist") then
          table.insert(getters, format("%s = %s.get_%s,", f.name, def.name, f.name))
        end
      end
    end

    self:writetemplate("msg_metatable", {name = def.name, msgdef = def, fields = funclist, getter_names = getters})
  end

  self:write([[
  function lib.gen_fbreaders(vtables)
    assert(type(vtables) == "table")
    local readers = {}
    for i = 1, MsgType.MAX do
      local name = MsgType.names[i]
      local type = ffi.typeof("$ *", msgtypes[name])
      readers[name] = function(ptr) return (ffi_cast(type, ptr)) end
    end
    return readers
  end
return lib
]])
end

return generator
