local util = require("jitlog.util")
local format = string.format
local buildtemplate = util.buildtemplate

local generator = {
  outputlang = "lua",
  default_filename = "reader_def.lua",
}

generator.templates = {
  comment_line = "-- %s",
  namelist = [[
local {{name}} = {
{{list:  "%s",\\n}}}

]],

  enum = [[
local {{name}} = make_enum{
{{list}}}
lib.{{name}} = {{name}}

]],
  enumline = '"%s",\n',
  msgsizes = [[local msgsizes = {
{{list:  %s\n}} };
lib.msgsizes = msgsizes

]],

  struct = [[
typedef struct MSG_{{name}}{
  {{fields}}
}__attribute__((packed))  MSG_{{name}};

]],
  structfield = "\n  %s %s;",
  struct_comment = "// %s",

  msg_metatable = [[
do
  local {{name}} = {}

{{fields:%s}}

  local getters = {
{{getter_names:    %s\n}}  }

  local function {{name}}_indexer(self, key)
    local getter = getters[key]
    if getter then
      return (getter(self))
    else
      local value = {{name}}[key]
      if not value then
        error("Unknown field " .. key .. " in message type {{name}}")
      end
      return value
    end
  end
  
  local {{name}}_mt = {
    __index =  {{name}}_indexer,
    getters = getters,
    funcs = {{name}},
  }
  
  ffi.metatype("MSG_{{name}}", {{name}}_mt)
end

]],

  msg_getter = [[
  function {{msgname}}:get_{{name}}()
    assert(self, "Expected a '{{msgname}}' message as first parameter")
    return {{body}}
  end

]],
}

function generator:fmt_fieldget(def, f)
  return "self."..f.name
end

function generator:needs_accessor(struct, f)
  return f.vlen or f.bitfield or f.bitstorage ~= nil
end

function generator:fmt_accessor_def(struct, f, voffset) 
  local body

  if f.vlen then
    local first_cast
    local second_cast

    if f.type == "string" then
      first_cast = "const char*"
      second_cast = "const char*"
    else
      first_cast = "char*"
      second_cast = self.types[f.type].c
    end
    
    if f.vindex == 1 then
      body = format([[ffi_cast("%s", self+1)]], second_cast)
    else
      body = format([[ffi_cast("%s", self+1) + (%s)]], first_cast, voffset)
    end
    
    local buflen
    if struct.use_msgsize then
      buflen = "self.msgsize - " .. struct.size
    elseif f.buflen then
      local buflen_field = struct.fieldlookup[f.buflen]
      assert(buflen_field)
      buflen = self:fmt_fieldget(struct, buflen_field)
    end

    if f.type == "string" then
      assert(buflen)
      body = format("(ffi.string(%s, %s))", body, buflen)
    elseif f.type == "stringlist" then
      assert(buflen)
      body = format("(parse_strlist(%s, %s))", body, buflen)
    else
      if f.vindex ~= 1 then -- We don't need a second cast if this is the first vlen field
        body = format([[ffi_cast("%s", %s)]], second_cast, body)
      end
      -- Add the buffer element count and element size as extra return values
      body = format([[%s, %s, %d]], body, buflen, f.element_size)
    end
  elseif f.bitfield or f.bitstorage then
    body = format("(band(rshift(%s, %d), 0x%x))", "self." .. f.bitstorage, f.bitofs, bit.lshift(1, f.bitsize)-1)
    if f.bool then
      body = body .. " ~= 0"
    end
  else
    assert(body, "unhandled field accessor type")
  end
  
  -- Prevent a tail call be generated by wrapping the body in parentheses
  return buildtemplate(self.templates.msg_getter, {msgname = struct.name, name = f.name, body = body})
end

function generator:fmt_accessor_get(struct, f, msgvar)
  return format("%s:get_%s()", msgvar, f.name)
end

function generator:fmt_namelookup(enum, idvar)
  return format("%s_names[%s]", enum, idvar)
end

function generator:writefile(options)
  self:write([=[
local ffi = require("ffi")
local ffi_cast = ffi.cast
local ffi_string = ffi.string
local band = bit.band
local rshift = bit.rshift
local lib = {}

local function make_enum(names)
  local t = {}
  for i, name in ipairs(names)do
      t[name] = i-1
  end
  t.names = names
  return t
end

local function parse_strlist(strlist, bufsize)
  local buf = ffi.cast("const char *", strlist)
  local prev = 0
  local t = {}
  
  for i =0, bufsize-1 do
    if buf[i] == 0 then
      local length = i - prev
      assert(length > 0)
      t[#t + 1] = ffi_string(buf +  prev, length)
      prev = i+1
    end
  end
  return t
end

local function nop() end

]=])
  self:write_enum("MsgType", self.sorted_msgnames)
  self:write_msgsizes(false)
  if GC64 then
    self:write([[
lib.GC64 = true

ffi.cdef("typedef uint64_t GCRef, MRef, GCSize;")]])
  else
    self:write([[
lib.GC64 = false

ffi.cdef("typedef uint32_t GCRef, MRef, GCSize;")]])
  end
  self:write([=[

ffi.cdef[[
]=])
  local struct_getters = {}
  for _, def in ipairs(self.msglist) do
    local field_getters = self:write_struct(def.name, def)
    if field_getters then
      struct_getters[def.name] = field_getters
    end
  end
  self:write("]]\n")

  for _, def in ipairs(self.msglist) do
    self:writef("assert(ffi.sizeof('MSG_%s') == %d)\n", def.name, def.size)
  end
  self:write("\n")
  
  for _, def in ipairs(self.msglist) do
    local funclist = struct_getters[def.name]
    local getters = {}
    if not funclist then
      funclist = {}
    else
      -- Build a table of properties names to getter functions used by the indexer
      for _, f in ipairs(def.fields) do
        if self:needs_accessor(def, f) and (not f.vlen or f.type == "string" or f.type == "stringlist") then
          table.insert(getters, format("%s = %s.get_%s,", f.name, def.name, f.name))
        end
      end
    end

    self:writetemplate("msg_metatable", {name = def.name, msgdef = def, fields = funclist, getter_names = getters})
  end

  self:write([[

return lib
]])
end

return generator
